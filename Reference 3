import os
import string
import random
import sys
import time
from datetime import datetime
from abc import ABC, abstractmethod


# -------------------------
# Encryption Class
# -------------------------
class Encryption:
    """
    Handles encryption and decryption of diary entries using a password-based cipher.
    """
    def __init__(self, key: str):
        """
        Initialize the encryption system with a password key.
        
        Args:
            key (str): The password that will be used to generate the cipher
        """
        self.key = key  # Store the encryption key (password)
        self.alphabet = string.ascii_letters + string.digits + string.punctuation + " "  # Create alphabet of all possible characters (letters, numbers, punctuation, space)
        self.cipher = self._make_cipher(key)  # Generate the cipher mapping based on the key
        self.reverse_cipher = {v: k for k, v in self.cipher.items()} 

    def _make_cipher(self, password: str):
        chars = list(self.alphabet)
        random.seed(password)  # makes cipher unique per password
        shuffled = chars.copy()
        random.shuffle(shuffled)
        return dict(zip(chars, shuffled))

    def encrypt(self, text: str) -> str:
        return "".join(self.cipher.get(c, c) for c in text)

    def decrypt(self, text: str) -> str:
        return "".join(self.reverse_cipher.get(c, c) for c in text)


# -------------------------
# DiaryEntry Base Class
# -------------------------
class DiaryEntry(ABC):
    def __init__(self, title: str, content: str, encryption, entry_date=None):
        self.title = title
        self.entry_date = entry_date if entry_date else datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.encrypted_content = encryption.encrypt(content)

    def get_content(self, encryption):
        return encryption.decrypt(self.encrypted_content)

    def set_content(self, new_content, encryption):
        self.encrypted_content = encryption.encrypt(new_content)

    def get_date(self):
        return self.entry_date

    def update_content(self, new_content, encryption):
        self.set_content(new_content, encryption)

    @abstractmethod
    def display_entry(self, encryption):
        pass


# -------------------------
# Subclasses
# -------------------------
class MyEntry(DiaryEntry):
    def display_entry(self, encryption):
        return f"Title: {self.title}\nDate: {self.entry_date}\nContent: {self.get_content(encryption)}"

    def __repr__(self):
        return f"<MyEntry title='{self.title}' date='{self.entry_date}'>"


class ReflectiveEntry(DiaryEntry):
    def __init__(self, title, content, mood, encryption, entry_date=None):
        super().__init__(title, content, encryption, entry_date)
        self.mood = mood

    def display_entry(self, encryption):
        return (f"Title: {self.title}\nMood: {self.mood}\nDate: {self.entry_date}\n"
                f"Content: {self.get_content(encryption)}")

    def __repr__(self):
        return f"<ReflectiveEntry title='{self.title}' mood='{self.mood}' date='{self.entry_date}'>"


# -------------------------
# User Class
# -------------------------
class User:
    def __init__(self, username: str, password: str, name: str):
        self.username = username
        self._password = password
        self.name = name

    def check_password(self, password: str):
        return self._password == password

    def change_password(self, old_pw: str, new_pw: str):
        if self._password == old_pw:
            self._password = new_pw
            print("Password changed successfully.")
            return True
        else:
            print("Wrong old password.")
            return False


# -------------------------
# DiarySystem Class
# -------------------------
class DiarySystem:
    def __init__(self, user: User):
        self.data_dir = self._get_data_directory()
        self.USER_FILE = os.path.join(self.data_dir, "users.txt")
        self.ENTRY_FILE = os.path.join(self.data_dir, "entries.txt")
        os.makedirs(self.data_dir, exist_ok=True)

        self.user = user
        self.encryption = Encryption(user._password)
        self.entries = self._load_entries()

    def _get_data_directory(self):
        home_dir = os.path.expanduser("~")  # ito inadd ko last night para compatible with diff OS
        
        if sys.platform == "darwin":  # macOS
            # Use ~/Library/Application Support/MySecretDiary
            data_dir = os.path.join(home_dir, "Library", "Application Support", "MySecretDiary")
        elif sys.platform.startswith("win"):  # Windows
            # Use %APPDATA%/MySecretDiary
            data_dir = os.path.join(os.environ.get("APPDATA", home_dir), "MySecretDiary")
        else:  # Linux and other Unix-like systems
            # Use ~/.local/share/MySecretDiary
            data_dir = os.path.join(home_dir, ".local", "share", "MySecretDiary")
        
        return data_dir

    # -------------------User Authentication Methods----------------------
    @classmethod
    def login_or_register(cls):
        # Keep this method self-contained so it can be called before an instance exists.
        try:
            sys.stdin.flush()
        except:
            pass
        time.sleep(0.1)

        temp_home = os.path.expanduser("~")
        if sys.platform == "darwin":
            temp_data_dir = os.path.join(temp_home, "Library", "Application Support", "MySecretDiary")
        elif sys.platform.startswith("win"):
            temp_data_dir = os.path.join(os.environ.get("APPDATA", temp_home), "MySecretDiary")
        else:
            temp_data_dir = os.path.join(temp_home, ".local", "share", "MySecretDiary")

        os.makedirs(temp_data_dir, exist_ok=True)
        user_file = os.path.join(temp_data_dir, "users.txt")

        users = {}
        if os.path.exists(user_file):
            try:
                with open(user_file, "r", encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line and "," in line:
                            parts = line.split(",", 2)
                            if len(parts) >= 3:
                                u, p, n = parts[0], parts[1], parts[2]
                                users[u] = (p, n)
            except (IOError, UnicodeDecodeError) as e:
                print(f"Error reading user file: {e}")
                print("Starting with empty user database.")

        while True:
            username = input("Enter username: ").strip()
            if (username.endswith('.py') or
                '\\' in username or
                '/' in username or
                username.startswith('C:') or
                len(username) > 50):
                print("Invalid username format. Please enter a simple username.")
                continue

            if not username:
                print("Username cannot be empty. Please try again.")
                continue

            break

        if username in users:
            password = input("Enter password: ")
            if users[username][0] == password:
                print("Login successful!")
                return User(username, password, users[username][1])
            else:
                print("Wrong password. Please try again.")
                return None
        else:
            print("New user. Let's register!")
            password = input("Set a password: ").strip()
            name = input("Enter your name: ").strip()

            if not username or not password or not name:
                print("All fields are required. Please try again.")
                return None

            if "," in username or "," in password or "," in name:
                print("Username, password, and name cannot contain commas. Please try again.")
                return None

            try:
                with open(user_file, "a", encoding="utf-8") as f:
                    f.write(f"{username},{password},{name}\n")

                print("Account created successfully!")
                return User(username, password, name)
            except IOError as e:
                print(f"Error saving user data: {e}")
                return None

    # ----------------- Entry Handling -----------------
    def _load_entries(self):
        entries = []
        if os.path.exists(self.ENTRY_FILE):
            try:
                with open(self.ENTRY_FILE, "r", encoding="utf-8") as f:
                    for line in f:
                        parts = line.strip().split("||")
                        if len(parts) >= 5:
                            entry_type = parts[0]
                            username = parts[1]
                            date = parts[2]
                            title = parts[3]
                            if username == self.user.username:
                                if entry_type == "REGULAR":
                                    encrypted = parts[4]
                                    entry = MyEntry(title, "", self.encryption, date)
                                    entry.encrypted_content = encrypted
                                    entries.append(entry)
                                elif entry_type == "REFLECTIVE" and len(parts) >= 6:
                                    mood = parts[4]
                                    encrypted = parts[5]
                                    entry = ReflectiveEntry(title, "", mood, self.encryption, date)
                                    entry.encrypted_content = encrypted
                                    entries.append(entry)
            except (IOError, UnicodeDecodeError) as e:
                print(f"Error reading entries file: {e}")
        return entries

    def _save_entries(self):
        all_entries = []
        if os.path.exists(self.ENTRY_FILE):
            try:
                with open(self.ENTRY_FILE, "r", encoding="utf-8") as f:
                    for line in f:
                        parts = line.strip().split("||")
                        if len(parts) >= 5 and parts[1] != self.user.username:
                            all_entries.append(line.strip())
            except (IOError, UnicodeDecodeError) as e:
                print(f"Warning: Error reading existing entries: {e}")

        for entry in self.entries:
            if isinstance(entry, ReflectiveEntry):
                entry_line = (
                    f"REFLECTIVE||{self.user.username}||{entry.get_date()}||"
                    f"{entry.title}||{entry.mood}||{entry.encrypted_content}"
                )
            else:
                entry_line = (
                    f"REGULAR||{self.user.username}||{entry.get_date()}||"
                    f"{entry.title}||{entry.encrypted_content}"
                )
            all_entries.append(entry_line)

        try:
            temp_file = self.ENTRY_FILE + ".tmp"
            with open(temp_file, "w", encoding="utf-8") as f:
                for entry_line in all_entries:
                    f.write(entry_line + "\n")
            os.replace(temp_file, self.ENTRY_FILE)
        except IOError as e:
            print(f"Error saving entries: {e}")

    def add_entry(self, title: str, content: str, mood: str = None):
        if mood:
            entry = ReflectiveEntry(title, content, mood, self.encryption)
        else:
            entry = MyEntry(title, content, self.encryption)
        self.entries.append(entry)
        self._save_entries()
        print("Entry added.")

    def list_entries(self):
        if not self.entries:
            print("No entries yet.")
            return
        for i, entry in enumerate(self.entries):
            entry_type = "Reflective" if isinstance(entry, ReflectiveEntry) else "Regular"
            print(f"{i}: [{entry_type}] {entry.title} ({entry.get_date()})")

    def view_entry(self, index: int):
        try:
            if 0 <= index < len(self.entries):
                print(self.entries[index].display_entry(self.encryption))
            else:
                print("Invalid entry index.")
        except (IndexError, ValueError):
            print("Invalid entry index.")

    def update_entry(self, index: int, new_content: str):
        try:
            if 0 <= index < len(self.entries):
                self.entries[index].update_content(new_content, self.encryption)
                self._save_entries()
                print("Entry updated.")
            else:
                print("Invalid entry index.")
        except (IndexError, ValueError):
            print("Invalid entry index.")

    def delete_entry(self, index: int):
        try:
            if 0 <= index < len(self.entries):
                del self.entries[index]
                self._save_entries()
                print("Entry deleted.")
            else:
                print("Invalid entry index.")
        except (IndexError, ValueError):
            print("Invalid entry index.")


# -------------------------
# CLI (User Journey)
# -------------------------
def main():
    try:
        print("Welcome to My Secret Diary!")
        user = None
        while not user:
            user = DiarySystem.login_or_register()

        diary = DiarySystem(user)

        while True:
            print("\nMenu:")
            print("1. Add entry")
            print("2. List entries")
            print("3. View entry")
            print("4. Update entry")
            print("5. Delete entry")
            print("6. Change password")
            print("0. Exit")

            choice = input("Choose option: ").strip()

            if choice == "1":
                title = input("Enter entry title: ")
                content = input("Write your entry: ")
                entry_type = input("Is this a reflective entry? (y/n): ").strip().lower()
                if entry_type == "y":
                    mood = input("Enter your mood (e.g., Happy, Sad, Excited): ").strip()
                    diary.add_entry(title, content, mood)
                else:
                    diary.add_entry(title, content)
            elif choice == "2":
                diary.list_entries()
            elif choice == "3":
                try:
                    index = int(input("Enter entry index: "))
                    diary.view_entry(index)
                except ValueError:
                    print("Please enter a valid number.")
            elif choice == "4":
                try:
                    index = int(input("Enter entry index: "))
                    new_content = input("Enter new content: ")
                    diary.update_entry(index, new_content)
                except ValueError:
                    print("Please enter a valid number.")
            elif choice == "5":
                try:
                    index = int(input("Enter entry index: "))
                    diary.delete_entry(index)
                except ValueError:
                    print("Please enter a valid number.")
            elif choice == "6":
                old_pw = input("Enter old password: ")
                new_pw = input("Enter new password: ")
                if user.change_password(old_pw, new_pw):
                    diary.encryption = Encryption(new_pw)
                    # Persist password change
                    try:
                        with open(diary.USER_FILE, "r", encoding="utf-8") as f:
                            lines = f.readlines()
                        with open(diary.USER_FILE, "w", encoding="utf-8") as f:
                            for line in lines:
                                if line.startswith(f"{user.username},"):
                                    f.write(f"{user.username},{new_pw},{user.name}\n")
                                else:
                                    f.write(line)
                    except IOError as e:
                        print(f"Warning: Could not update password in file: {e}")
            elif choice == "0":
                print("Goodbye!")
                break
            else:
                print("Invalid option. Try again.")

    except KeyboardInterrupt:
        print("\n\nProgram interrupted by user. Goodbye!")
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")
        print("Please try again.")


if __name__ == "__main__":
    main()
