import os
import string
import random
import sys
import time
from datetime import datetime
from abc import ABC, abstractmethod


# -------------------------
# Encryption Class
# -------------------------
class Encryption:
    """
    Handles encryption and decryption of diary entries using a password-based cipher.
    """
    def __init__(self, key: str):
        """
        Initialize the encryption system with a password key.
        
        Args:
            key (str): The password that will be used to generate the cipher
        """
        self.key = key  # Store the encryption key (password)
        self.alphabet = string.ascii_letters + string.digits + string.punctuation + " "  # Create alphabet of all possible characters (letters, numbers, punctuation, space)
        self.cipher = self._make_cipher(key)  # Generate the cipher mapping based on the key
        self.reverse_cipher = {v: k for k, v in self.cipher.items()} 

    def _make_cipher(self, password: str):
        '''Creates a cipher for the text'''
        chars = list(self.alphabet)
        random.seed(password)  # makes cipher unique per password
        shuffled = chars.copy()
        random.shuffle(shuffled)
        return dict(zip(chars, shuffled))

    def encrypt(self, text: str) -> str:
        '''Encrypts a diary entry'''
        return "".join(self.cipher.get(c, c) for c in text)

    def decrypt(self, text: str) -> str:
        '''Decrypts a diary entry'''
        return "".join(self.reverse_cipher.get(c, c) for c in text)
    
    def change_encryption_key (self, new_encryption_key: str):
        '''Changes the encryption key'''
        self.key = new_encryption_key
        self._make_cipher(new_encryption_key)
        self.reverse_cipher = {v: k for k, v in self.cipher.items()} 


# -------------------------
# DiaryEntry Base Class
# -------------------------
class DiaryEntry(ABC):
    '''
    Represents a diary entry in the system.
    This is the base class, and other diary entry types will inherit from it.
    '''

    def __init__(self, title: str, content: str, encryption, entry_date=None):
        '''
        Creates a new diary entry.

        Parameters:
        title: The title of the entry.
        content: The content of the entry.
        encryption: Used to encrypt the content.
        entry_date: The date of the entry (default is current date and time).
        '''
        self.title = title
        self.entry_date = entry_date if entry_date else datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.encrypted_content = encryption.encrypt(content)

    def get_content(self, encryption):
        '''
        Gets the decrypted content of the entry.
        '''
        return encryption.decrypt(self.encrypted_content)

    def set_content(self, new_content, encryption):
        '''
        Sets the content of the entry with new content.
        '''
        self.encrypted_content = encryption.encrypt(new_content)

    def get_date(self):
        '''
        Gets the date of the entry.
        '''
        return self.entry_date

    def update_content(self, new_content, encryption):
        '''
        Updates the content of the entry.
        '''
        self.set_content(new_content, encryption)

    @abstractmethod
    def display_entry(self, encryption):
        '''
        Shows the entry details.
        This must be made in the subclasses.
        '''
        pass


# ------------------------------
# Diary Entry Subclass (MyEntry)
# ------------------------------
class MyEntry(DiaryEntry):
    '''
    Represents a personal diary entry.
    This is a simple type of entry where you only write what happened.
    This subclass implements the display_entry method for standard diary entries.
    '''

    def display_entry(self, encryption):
        '''
        Shows the entry with title, date, and content.
        '''
        return f"Title: {self.title}\nDate: {self.entry_date}\nContent: {self.get_content(encryption)}"

    def __repr__(self):
        '''
        Shows the MyEntry object in text form.
        '''
        return f"<MyEntry title='{self.title}' date='{self.entry_date}'>"


# ---------------------------------------
# Diary Entry Subclass (ReflectiveEntry)
# ---------------------------------------
class ReflectiveEntry(DiaryEntry):
    '''
    Represents a reflective diary entry.
    The subclass a type of entry where you write not only what happened but also how you felt about it. 
    This subclass includes an additional attribute 'mood' to describe the emotional tone of the entry.
    '''

    def __init__(self, title, content, mood, encryption, entry_date=None):
        '''
        Creates a reflective diary entry.

        Parameters:
        title: The title of the entry.
        content: The content of the entry.
        mood: The mood of the entry.
        encryption: Used to encrypt the content.
        entry_date: The date of the entry (default is current date and time).
        '''
        super().__init__(title, content, encryption, entry_date)
        self.mood = mood

    def display_entry(self, encryption):
        '''
        Shows the entry with title, mood, date, and content.
        '''
        return (f"Title: {self.title}\nMood: {self.mood}\nDate: {self.entry_date}\n"
                f"Content: {self.get_content(encryption)}")

    def __repr__(self):
        '''
        Shows the ReflectiveEntry object in text form.
        '''
        return f"<ReflectiveEntry title='{self.title}' mood='{self.mood}' date='{self.entry_date}'>"

# -------------------------
# User Class
# -------------------------
class User:
    ''' 
    Represents a user in the diary systme.
    '''
    def __init__(self, username: str, password: str, name: str):
        '''
        Initializes a new instance of the User class.
        Parameters:
        username (str): Unique username for the user.        
        password (str): Password for the user's account.    
        name (str): Full name of the user.                  
        '''
        self.username = username        # Store the username
        self._password = password       # Store the password
        self.name = name                # Store the user's full name

    def check_password(self, password: str):
        ''' returns the passwod of the user.'''
        return self._password == password

    def change_password(self, old_pw: str, new_pw: str):
        ''' returns the changed passwod of the user.'''
        if self._password == old_pw:         # Verify old password
            self._password = new_pw          # Update to new password
            print("Password changed successfully.")
            return True
        else:
            print("Wrong old password.")
            return False


# -------------------------
# DiarySystem Class
# -------------------------
class DiarySystem:
    ''' 
    Manages diary entries, user authentication, and data storage.
    '''
    def __init__(self, user: User):                         
        '''
        Initializes the DiarySystem for the given user.
        Parameters:
        user (User): The authenticated user.
        '''
        self.data_dir = self._get_data_directory()                          # Identify the correct directory for storing data files.
        self.USER_FILE = os.path.join(self.data_dir, "users.txt")           # Define file paths for storing users and diary entries
        self.ENTRY_FILE = os.path.join(self.data_dir, "entries.txt")        # Define file paths for storing users and diary entries
        os.makedirs(self.data_dir, exist_ok=True)                           # Create the directory if it doesn't exist

        self.user = user                                                    # Store the user object
        self.encryption = Encryption(user._password)                        # Create an Encryption object using the user's password
        self.entries = self._load_entries()                                 # Load existing diary entries from file

    def _get_data_directory(self):
        '''Returns to str: Path to the data storage directory.'''
        home_dir = os.path.expanduser("~")  # ito inadd ko last night para compatible with diff OS
        
        if sys.platform == "darwin":  # macOS
            # Use ~/Library/Application Support/MySecretDiary
            data_dir = os.path.join(home_dir, "Library", "Application Support", "MySecretDiary")
        elif sys.platform.startswith("win"):  # Windows
            # Use %APPDATA%/MySecretDiary
            data_dir = os.path.join(os.environ.get("APPDATA", home_dir), "MySecretDiary")
        else:  # Linux and other Unix-like systems
            # Use ~/.local/share/MySecretDiary
            data_dir = os.path.join(home_dir, ".local", "share", "MySecretDiary")
        
        return data_dir

    # -------------------User Authentication Methods----------------------
    @classmethod
    def login_or_register(cls):
        # Keep this method self-contained so it can be called before an instance exists.
        try:
            sys.stdin.flush()
        except:
            pass
        time.sleep(0.1)

        temp_home = os.path.expanduser("~")
        if sys.platform == "darwin":
            temp_data_dir = os.path.join(temp_home, "Library", "Application Support", "MySecretDiary")
        elif sys.platform.startswith("win"):
            temp_data_dir = os.path.join(os.environ.get("APPDATA", temp_home), "MySecretDiary")
        else:
            temp_data_dir = os.path.join(temp_home, ".local", "share", "MySecretDiary")

        os.makedirs(temp_data_dir, exist_ok=True)
        user_file = os.path.join(temp_data_dir, "users.txt")

        users = {}
        if os.path.exists(user_file):
            try:
                with open(user_file, "r", encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line and "," in line:
                            parts = line.split(",", 2)
                            if len(parts) >= 3:
                                u, p, n = parts[0], parts[1], parts[2]
                                users[u] = (p, n)
            except (IOError, UnicodeDecodeError) as e:
                print(f"Error reading user file: {e}")
                print("Starting with empty user database.")

        while True:
            username = input("Enter username: ").strip()
            if (username.endswith('.py') or
                '\\' in username or
                '/' in username or
                username.startswith('C:') or
                len(username) > 50):
                print("Invalid username format. Please enter a simple username.")
                continue

            if not username:
                print("Username cannot be empty. Please try again.")
                continue

            break

        if username in users:
            password = input("Enter password: ")
            if users[username][0] == password:
                print("Login successful!")
                return User(username, password, users[username][1])
            else:
                print("Wrong password. Please try again.")
                return None
        else:
            print("New user. Let's register!")
            password = input("Set a password: ").strip()
            name = input("Enter your name: ").strip()

            if not username or not password or not name:
                print("All fields are required. Please try again.")
                return None

            if "," in username or "," in password or "," in name:
                print("Username, password, and name cannot contain commas. Please try again.")
                return None

            try:
                with open(user_file, "a", encoding="utf-8") as f:
                    f.write(f"{username},{password},{name}\n")

                print("Account created successfully!")
                return User(username, password, name)
            except IOError as e:
                print(f"Error saving user data: {e}")
                return None

    # ----------------- Entry Handling -----------------
    def _load_entries(self):
        '''
        Load entries belonging to the current user from the entry file.
        '''
        entries = []
        if os.path.exists(self.ENTRY_FILE):
            try:
                with open(self.ENTRY_FILE, "r", encoding="utf-8") as f:
                    for line in f:
                        parts = line.strip().split("||")
                        if len(parts) >= 5:
                            entry_type = parts[0]
                            username = parts[1]
                            date = parts[2]
                            title = parts[3]
                            if username == self.user.username:
                                if entry_type == "REGULAR":
                                    encrypted = parts[4]
                                    entry = MyEntry(title, "", self.encryption, date)
                                    entry.encrypted_content = encrypted
                                    entries.append(entry)
                                elif entry_type == "REFLECTIVE" and len(parts) >= 6:
                                    mood = parts[4]
                                    encrypted = parts[5]
                                    entry = ReflectiveEntry(title, "", mood, self.encryption, date)
                                    entry.encrypted_content = encrypted
                                    entries.append(entry)
            except (IOError, UnicodeDecodeError) as e:
                print(f"Error reading entries file: {e}")
        return entries

    def _save_entries(self):
        '''
        Save all entries back to file.
        '''
        all_entries = []
        if os.path.exists(self.ENTRY_FILE):
            try:
                with open(self.ENTRY_FILE, "r", encoding="utf-8") as f:
                    for line in f:
                        parts = line.strip().split("||")
                        if len(parts) >= 5 and parts[1] != self.user.username:
                            all_entries.append(line.strip())
            except (IOError, UnicodeDecodeError) as e:
                print(f"Warning: Error reading existing entries: {e}")

        for entry in self.entries:
            if isinstance(entry, ReflectiveEntry):
                entry_line = (
                    f"REFLECTIVE||{self.user.username}||{entry.get_date()}||"
                    f"{entry.title}||{entry.mood}||{entry.encrypted_content}"
                )
            else:
                entry_line = (
                    f"REGULAR||{self.user.username}||{entry.get_date()}||"
                    f"{entry.title}||{entry.encrypted_content}"
                )
            all_entries.append(entry_line)

        try:
            temp_file = self.ENTRY_FILE + ".tmp"
            with open(temp_file, "w", encoding="utf-8") as f:
                for entry_line in all_entries:
                    f.write(entry_line + "\n")
            os.replace(temp_file, self.ENTRY_FILE)
        except IOError as e:
            print(f"Error saving entries: {e}")

    def add_entry(self, title: str, content: str, mood: str = None):
        '''
        Add a new entry for the current user.
        '''
        if mood:
            entry = ReflectiveEntry(title, content, mood, self.encryption)
        else:
            entry = MyEntry(title, content, self.encryption)
        self.entries.append(entry)
        self._save_entries()
        print("Entry added.")

    def list_entries(self):
        '''
        Display a list of all entries for the current user.
        '''
        if not self.entries:
            print("No entries yet.")
            return
        for i, entry in enumerate(self.entries):
            entry_type = "Reflective" if isinstance(entry, ReflectiveEntry) else "Regular"
            print(f"{i}: [{entry_type}] {entry.title} ({entry.get_date()})")

    def view_entry(self, index: int):
        '''
        Display the content of a specific entry.
        '''
        try:
            if 0 <= index < len(self.entries):
                print(self.entries[index].display_entry(self.encryption))
            else:
                print("Invalid entry index.")
        except (IndexError, ValueError):
            print("Invalid entry index.")

    def update_entry(self, index: int, new_content: str):
        ''' 
        Update the content of an existing entry.
        '''
        try:
            if 0 <= index < len(self.entries):
                self.entries[index].update_content(new_content, self.encryption)
                self._save_entries()
                print("Entry updated.")
            else:
                print("Invalid entry index.")
        except (IndexError, ValueError):
            print("Invalid entry index.")

    def delete_entry(self, index: int):
        ''' 
        Delete an entry from the current user's list.
        '''
        try:
            if 0 <= index < len(self.entries):
                del self.entries[index]
                self._save_entries()
                print("Entry deleted.")
            else:
                print("Invalid entry index.")
        except (IndexError, ValueError):
            print("Invalid entry index.")


# -------------------------
# CLI (User Journey)
# -------------------------
def main():
    """
    Function that runs the Secret Diary application.
    
    Shows (text based) welcome message, handles login, and displays menu options
    for managing diary entries until user exits.
    """
try:
        # Show welcome message
        print("Welcome to My Secret Diary!")
        user = None
        
        # Keep asking for login until successful
        while not user:
            user = DiarySystem.login_or_register()
        
        # Create diary system for logged in user
        diary = DiarySystem(user)
        
        # Show menu and handle user choices
        while True:
            # Display all menu options
            print("\nMenu:")
            print("1. Add entry")
            print("2. List entries") 
            print("3. View entry")
            print("4. Update entry")
            print("5. Delete entry")
            print("6. Change password")
            print("0. Exit")
            
            # Get user's menu choice
            choice = input("Choose option: ").strip()
            
            if choice == "1":
                # Create new diary entry
                title = input("Enter entry title: ")
                content = input("Write your entry: ")
                entry_type = input("Is this a reflective entry? (y/n): ").strip().lower()
                
                # Check if user wants mood tracking
                if entry_type == "y":
                    # Add reflective entry with mood
                    mood = input("Enter your mood (e.g., Happy, Sad, Excited): ").strip()
                    diary.add_entry(title, content, mood)
                else:
                    # Add regular entry without mood
                    diary.add_entry(title, content)
                    
            elif choice == "2":
                # Show all entries with their titles and dates
                diary.list_entries()
                
            elif choice == "3":
                # Display full content of selected entry
                try:
                    # Get entry number from user
                    index = int(input("Enter entry index: "))
                    diary.view_entry(index)
                except ValueError:
                    # Handle non-number input
                    print("Please enter a valid number.")
                    
            elif choice == "4":
                # Edit existing entry content
                try:
                    # Get entry number to edit
                    index = int(input("Enter entry index: "))
                    new_content = input("Enter new content: ")
                    diary.update_entry(index, new_content)
                except ValueError:
                    # Handle non-number input
                    print("Please enter a valid number.")
                    
            elif choice == "5":
                # Remove entry permanently
                try:
                    # Get entry number to delete
                    index = int(input("Enter entry index: "))
                    diary.delete_entry(index)
                except ValueError:
                    # Handle non-number input
                    print("Please enter a valid number.")
            elif choice == "6":
                # Update password and save to file
                old_pw = input("Enter old password: ")
                new_pw = input("Enter new password: ")
                
                # Check if old password is correct
                if user.change_password(old_pw, new_pw):
                    # Update encryption with new password
                    diary.encryption = Encryption(new_pw)
                    
                    # Save new password to users.txt file
                    try:
                        # Read all user data from file
                        with open(diary.USER_FILE, "r", encoding="utf-8") as f:
                            lines = f.readlines()
                        
                        # Write back with updated password
                        with open(diary.USER_FILE, "w", encoding="utf-8") as f:
                            for line in lines:
                                if line.startswith(f"{user.username},"):
                                    # Replace this user's line with new password
                                    f.write(f"{user.username},{new_pw},{user.name}\n")
                                else:
                                    # Keep other users' data unchanged
                                    f.write(line)
                    except IOError as e:
                        print(f"Warning: Could not update password in file: {e}")
                        
            elif choice == "0":
                # Exit the program
                print("Goodbye!")
                break
            else:
                # Handle invalid menu choices
                print("Invalid option. Try again.")
    
except KeyboardInterrupt:
# Handle Ctrl+C gracefully #For error handling, instead of crashing, this code catches it and forcefullu closing the program
    print("\n\nProgram interrupted by user. Goodbye!")
except Exception as e:
    # Handle any unexpected errors
    print(f"\nAn unexpected error occurred: {e}")
    print("Please try again.")


if __name__ == "__main__":
    main()
   
